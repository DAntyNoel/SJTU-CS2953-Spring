Memory allocator

正如tutorial中所说，为了避免kmem锁被多个CPU核反复争抢，只需要给每个
CPU分配锁即可。因为每个CPU的内存管理是相互独立的，因此分开上锁能显著
减少争抢次数，

代码实现方面，只需要将锁分配多个就行，安全获取cpuid之后只需要访问自己
线程的锁即可，比较容易。

有一点值得注意的是我一开始的争抢函数写的有点问题，我最终的处理方式是给
予了一半的freelist。这里用了链表计数指针来获取中间的指针位置。


Buffer Cache

我其实非常不理解为什么Buffer Cache与Memory allocator差距如此大，
采用类似的方式解决理论上也能满足需求，不需要什么哈希表或者链表来快速
索引。但其实核心思路还是一致的。减少锁争用的唯一方式还是只能分配多个
锁。利用哈希表将缓存块分类上锁就行。

代码实现方面，既然核心思路与第一个任务一致，那么锁的改进就不是问题。
难点可能在维护哈希表上。考虑到修改哈希表的时候要避免死锁的出现，因此
我直接考虑了对整体哈希表加锁，并且这个锁要独立于bcache的整体锁，（
感觉上锁越多，锁的功能越细，死锁的出现可能就越小）头脑风暴过后只能想
到一种情况可能造成死锁：当bcache无空闲区块，重新分配内存序号时需要对
哈希表进行下表索引修改，此时另一个程序来访问哈希表的时候可能会造成冲突。

具体运行过程中DEBUG是个非常头疼的操作。因为我本人不喜欢gdb调试，更多
会是通过打断点输出来检测运行情况，但bcache由于涉及内核分配且始终在运
行，有错误会导致kernel boot失败，没法执行调试。这点还是比较费劲的。
不过最终发现问题不是自己的愚蠢语法错误就是结构体声明的不对。